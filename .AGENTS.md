# .AGENTS.md

AI agent instructions for the MeshIt codebase.

## Quick Reference

- **Stack**: Next.js 16, React 19, TypeScript (strict), Tailwind CSS 4, Supabase, shadcn/ui
- **Package Manager**: pnpm (required, enforced)
- **Dev Server**: `pnpm dev`
- **Lint**: `pnpm lint`
- **Tests**: `pnpm test` (unit, watch), `pnpm test:run` (unit, once), `pnpm test:e2e` (E2E)
- **Type Check**: `pnpm tsc --noEmit`
- **Build**: `pnpm build`
- **Add UI Components**: `pnpm dlx shadcn@latest add [component]`

## Conventions

- Follow conventional commit format: `type(scope): description` (e.g. `feat(matching): add location filter`)
- Pre-commit hook runs Prettier + ESLint on staged files via lint-staged
- Branch naming: `feat/`, `fix/`, `chore/`, `refactor/`, `docs/`, `test/` prefixes
- See `CONTRIBUTING.md` for full team conventions
- If the work contains planning, update specs in `spec/`

## Roadmap & Versioning

- When completing a feature listed in `spec/roadmap.md`, mark it as done (`- [x]`) and move it to "Implemented"
- When a milestone's features are all complete, bump `package.json` version and note in roadmap
- Feature PRs that implement roadmap items must update `spec/roadmap.md`
- Use milestone-based semver: minor bump per milestone, patch for fixes

## Git Workflow

> **MANDATORY**: For any code changes, create a **git worktree** branched off `dev` (unless in the web environment). Never commit code directly to `dev` or `main`. Documentation-only changes on `dev` are acceptable.

- Never work directly on `main`, almost never directly on `dev` — always use a feature/fix/… branch
  - `dev` is fine for updating specs and documentation only
- If your work doesn't match the current branch's theme, create a new feature branch
- **Worktree setup**: `git worktree add ../MeshIt-<branch-name> -b <branch-name> dev` then symlink `.env`
- Commit and push freely when on your own feature/fix branch
- Only open a PR (target: `dev`) when work is complete and tests pass
- After completing work on an issue, update its status via `gh` CLI (e.g. `gh issue close N --comment "..."`)
- When creating related work, open new issues with `gh issue create`

## Worktrees

- `.env` is not present in new worktrees — symlink from main repo: `ln -s /home/ajb/repos/MeshIt/.env .env`
- Never `cp` the `.env` — symlinks stay in sync and avoid permission prompts
- Shell cwd may reset to the main repo after commands — use absolute paths or verify cwd

## Build Requirements

### Environment

Ensure `.env` (or `.env.local`) exists before running tests or dev server.

### Pre-Deployment Testing

Always run `pnpm build` before deploying to catch build-time errors.

### Stale Cache

"Element type is undefined" errors in dev mode can be caused by a stale `.next` cache, not a code bug. Fix: `rm -rf .next`, clear browser site data, restart `pnpm dev`.

### Suspense Boundaries

- `useSearchParams()` must be wrapped in `<Suspense>` to avoid build errors
- Extract component using `useSearchParams()` into separate component, wrap default export with Suspense

## Post-Task Testing Checklist

Before opening a PR, complete this checklist:

### 1. Run tests

- Run `pnpm test:run` — all unit tests must pass
- Run `pnpm test:e2e` — check E2E tests, especially if you changed UI, routes, auth, or user flows
- Run `pnpm lint` and `pnpm tsc --noEmit` — no new errors
- If you changed UI components or pages, note what needs browser testing

### 2. Assess test coverage for your changes

- **New utility/lib code**: Must have unit tests (co-located in `__tests__/` next to the module)
- **New API routes**: Must have unit tests for the route handler (mock Supabase, test auth, test response shapes)
- **New hooks**: Must have unit tests (use `renderHook` from `@testing-library/react`)
- **New/modified UI components**: Unit tests recommended; if skipped, file an `untested` issue
- **Bug fixes**: Must include a regression test that would have caught the bug

### 3. Declare test gaps in your PR

- Fill in the **Test Gaps** section of the PR template honestly
- If any code paths remain untested, create a GitHub issue:
  ```bash
  gh issue create --title "test: [module/component name] lacks unit tests" \
    --label "untested" \
    --body "## What needs tests\n\n[describe the untested code]\n\n## Why not tested now\n\n[reason]\n\n## Suggested approach\n\n[how to test it]"
  ```

### 4. Flag browser-testing needs

- If your change affects UI rendering, interactivity, or responsive layout:
  - Add the `needs-browser-test` label to the PR
  - Fill in the **Browser Testing Needed** section of the PR template
  - List specific pages/flows to verify (e.g., "posting detail page at /postings/[id]")

### Test file conventions

- Unit tests: `src/<path>/__tests__/<module>.test.ts` (co-located)
- E2E tests: `tests/e2e/<feature>.spec.ts`
- Test utilities/factories: `tests/utils/` and `tests/fixtures/`
- Use existing test patterns as reference (see `src/lib/api/__tests__/with-auth.test.ts` for API route pattern, `src/lib/matching/__tests__/similarity.test.ts` for pure utility pattern)

## Supabase CLI

```bash
# Link to project (one-time setup)
supabase link --project-ref YOUR_PROJECT_REF

# Create migration
supabase migration new migration_name

# Apply migrations to remote database
supabase db push

# Check migration status
supabase migration list

# Pull remote schema changes
supabase db pull
```

When updating database model, update `docs/data-model.md`.

### Expand-Contract Migration Pattern

Use expand-contract for **breaking schema changes** (drop column, rename column, change type). This avoids downtime by splitting the change into two PRs:

1. **Expand** (PR 1): Add new column / stop reading old column in code. Deploy to `main`.
2. **Contract** (PR 2): Drop old column / index via migration. Deploy after Expand is live.

**Examples:**

- **Drop column `foo`**: PR 1 removes all code refs to `foo`. PR 2 migration: `ALTER TABLE t DROP COLUMN IF EXISTS foo;`
- **Rename column `old` → `new`**: PR 1 adds `new`, code reads `new` with `COALESCE(new, old)` fallback. PR 2 migration: backfill `new` from `old`, drop `old`.

**Rules:**

- Never drop a column that code still references
- Always deploy Expand first and verify in production before Contract
- Apply migrations to dev project first, verify, then prod

### Multi-Project Setup

| Environment       | Supabase Project | Config Source   |
| ----------------- | ---------------- | --------------- |
| Local dev         | `meshit-dev`     | `.env`          |
| Vercel Preview    | `meshit-dev`     | Vercel env vars |
| Vercel Production | `meshit` (prod)  | Vercel env vars |

**Switching projects locally:**

- Update `NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY`, `SUPABASE_SECRET_KEY` in `.env`
- Run `supabase link --project-ref <ref>` to point CLI at the target project

**Migration order:**

1. Develop and test migration on `meshit-dev` (`supabase db push`)
2. Verify in preview deployment
3. Apply to `meshit` (prod) via `supabase db push` after linking to prod ref

## Key Directories

- `src/app/` - Next.js App Router pages and API routes
- `src/components/` - React components (layout, ui, match, project, profile)
- `src/lib/` - Utilities (supabase, matching, ai, hooks, types)
- `spec/` - Product specifications
- `docs/` - Technical documentation
- `tests/` - E2E and integration tests
- `supabase/migrations/` - SQL migration files
- `.prompts/` - Prompt files for AI agents (contents gitignored, see `Prompts.md` inside)
- `.handoffs/` - Task handoff briefs for parallel Claude Code sessions (contents gitignored)

## Handoffs

The `.handoffs/` directory contains self-contained task briefs for delegating work to parallel Claude Code sessions (e.g. Claude Code on the web). Each file includes:

- Setup instructions (clone, branch, install)
- Task scope and sub-task breakdown
- Relevant database schema and existing code context
- Code patterns to follow (API routes, SWR hooks)
- Testing and verification checklist
- Commit conventions

To use: copy-paste the contents of a handoff file into a new Claude Code session. The agent will clone the repo and work independently on its feature branch. You'll need to provide `.env` separately since it's not in git.
